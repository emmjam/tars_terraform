#!/bin/bash +x

function log () {
  case $1 in
    "INFO")
      LOG_COLOR="\033[96m";;
    "ERROR")
      LOG_COLOR="\033[31m";;
    "WARN")
      LOG_COLOR="\033[93m" ;;
    "SUCCESS")
      LOG_COLOR="\033[32m" ;;
    *)
      LOG_COLOR="\033[1m" ;;
  esac

  echo -e "$${LOG_COLOR} [$(date)] $${1}: $2\033[0m" | tee -a "/var/log/bootstrap.log"
}

function error () {
  log "ERROR" "$1"
  exit
}

# Python is the best bet to safely escape the log data
# for json consumption. json is a std python lib so 
# minimal dependency requirements
function json_escape () {
    printf '%s' "$1" | python -c 'import json,sys; print(json.dumps(sys.stdin.read()))'
}

export aws="$(which aws || echo '/usr/bin/aws')";
export curl="$(which curl || echo '/usr/bin/curl')";

# Instance ID begets all things...
log 'INFO' 'Retrieving Instance ID from Metadata';
instance_id="$($${curl} -s http://169.254.169.254/latest/meta-data/instance-id)";
if [ $${?} -ne 0 ]; then
  error "Failed to retrieve Instance ID";
fi
log 'INFO' "Instance ID: $${instance_id}";

# Get Current AWS Region in order to do anything useful...
log 'INFO' 'Retrieving Instance Identity Document from Metadata';
instance_identity_document="$($${curl} -s http://169.254.169.254/latest/dynamic/instance-identity/document)";
if [ $${?} -ne 0 ]; then
  error "$${curl} -s http://169.254.169.254/latest/dynamic/instance-identity/document";
else
  log 'INFO' 'Instance Identity Document Retrieved';

  region="$(echo "$${instance_identity_document}" | jq -r .region)";

  if [ $${?} -ne 0 ]; then
    error 'jq: Instance Identity Document could not be parsed for current Region';
  else
    log 'INFO' "Region retrieved: $${region}";
  fi;

  # Make it available to the AWS cli; who needs to specify the region manually on every single call(?)
  export AWS_DEFAULT_REGION="$${region}";
fi;

# Get the Autoscaling Group Name - it's a bit dirty but it works.
asg_name="$($${aws} autoscaling describe-auto-scaling-instances \
  --instance "$${instance_id}" \
  --output json \
  | jq -r .AutoScalingInstances[0].AutoScalingGroupName)";

if [ $${?} -ne 0 ]; then
  error 'Failed to retrieve the autoscaling group name for this instance';
else
  log 'INFO' "ASG name retrieved: $${asg_name}";
fi;

# Get the Launching LifeCycle Hook Name for this ASG (Making the assumption there's only one hook!)
lifecycle_hook_name="$($${aws} autoscaling describe-lifecycle-hooks \
  --auto-scaling-group-name "$${asg_name}" \
  --output json \
  | jq -r '.LifecycleHooks[] | select(.LifecycleTransition=="autoscaling:EC2_INSTANCE_LAUNCHING") | .LifecycleHookName')";

if [ $${?} -ne 0 ]; then
  error "Failed to retrieve lifecycle hook name for the autoscaling:EC2_INSTANCE_LAUNCHING transition for the autoscaling group named: $${asg_name}";
else
  log 'INFO' "Lifecycle hook name retrieved: $${lifecycle_hook_name}"
fi;

# Prerequisite information gathered - begin bootstrapping

BOOTSTRAP_SUCCESS=1

sed -E -i "s/'[a-z0-9]{8}\-[a-z0-9]{4}\-[a-z0-9]{4}\-[a-f0-9]{4}\-[a-z0-9]{12}'/'${KMS_KEY}'/g" /etc/eyaml/config.yaml

# Shift this to cloud-init config yaml
facts_path="/opt/puppetlabs/facter/facts.d"
echo -n 'environment: ${ENVIRONMENT}'    > "$${facts_path}/environment.yaml"
echo -n 'nodetype: ${NODETYPE}'          > "$${facts_path}/nodetype.yaml"
echo -n 'aws_account: ${AWS_ACCOUNT_ID}' > "$${facts_path}/aws_account.yaml"

log 'INFO' 'Configuring EFS'

# Ensure the directory exists
mkdir -p ${MOUNT_POINT_ENC};

# Get Region and AZ from AWS EC2 meta-data. We could take region as a template parameter, but why since meta-data is canonical?
export region="$(curl -s http://169.254.169.254/latest/dynamic/instance-identity/document | jq -r .region)";
export az="$(curl -s http://169.254.169.254/latest/meta-data/placement/availability-zone)";

# TODO: peacheym: Migrate to the AZ-independent URL
# Set mount information in /etc/fstab - we're unlikely to reboot, but it can't hurt to ensure it remains

# echo "$${az}.${EFS_ENC_ID}.efs.$${region}.amazonaws.com:/ ${MOUNT_POINT_ENC} efs rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2,noresvport,tls 0 0" >> /etc/fstab

######################################################################
##### TEMPORRARY FIX !!! #############################################
# This to use IP addresses until such time as the DNS issue is fixed and the above fstab will work in a self-heal scenario

EFS_IP_ENC=$(aws efs describe-mount-targets --file-system-id ${EFS_ENC_ID} --query "MountTargets[?AvailabilityZoneName == '$${az}'].IpAddress" --output text)
echo "$${EFS_IP_ENC}:/ ${MOUNT_POINT_ENC} nfs4 nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2 0 0 # $${az}.${EFS_ENC_ID}.efs.$${region}.amazonaws.com" >> /etc/fstab

##### END OF TEMPORRARY FIX !!! ######################################
######################################################################

# Mount the configured target for Batch
mount ${MOUNT_POINT_ENC};

cd /opt/packer-puppet-masterless

log 'INFO' 'Running puppet to configure environment'

/opt/puppetlabs/bin/puppet apply \
  --verbose \
  --detailed-exitcodes \
  --modulepath='/opt/packer-puppet-masterless/module-0:/opt/packer-puppet-masterless/module-1' \
  --hiera_config='/opt/packer-puppet-masterless/hiera.yaml' \
  /opt/packer-puppet-masterless/manifests/site.pp

case $${?} in
  6|4|1)
    log "ERROR" "Puppet run failed with exit code $${?}"
    BOOTSTRAP_SUCCESS=0 ;;
  *)
    log "INFO" "Puppet run completed" ;;
esac

if [ $${BOOTSTRAP_SUCCESS} -eq 1 ]; then
  log 'SUCCESS' 'Bootstrap complete for nodetype: ${NODETYPE}'
else
  log 'ERROR' 'Bootstrap abandon for nodetype: ${NODETYPE}'
fi

sed -i -e "s|production|${ENVIRONMENT}|g" /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.toml
/etc/init.d/cloudwatch restart

# Sure would be lovely if date could give unix time 
# in milliseconds
timestamp=$(($(date +'%s * 1000 + %-N / 1000000')))
log_data="$(json_escape "$(cat /var/log/cloud-init-output.log)")"


# begin d90 certificate retrieval
# limited to just opsdev to start with
if [ "${ENVIRONMENT}" == "opsdev" ]; then
  log "INFO" "Environment is opsdev, beginning d90 cert retrieval from parameter store"

  # set variables
  certificate_directory="/tmp/cert"
  java_path="/usr/lib/jvm/java-1.8.0-amazon-corretto.x86_64/bin"
  if [ "${ACCOUNT_ENVIRONMENT}" == "nonprod" ]; then
    d90_soap_client="d90-soap-test-client-jks"
    services04_crt="dvla-UASERVICES04-CA-crt"
    services03_crt="dvla-UASERVICES03-CA-crt"
    d90_soap_crt="D90-SOAP-TEST-crt"
    d90_soap_private_key="D90-SOAP-TEST-private-key"
    d90_soap="d90_soap_test"
    d90_keystore="d90_soap_test_client"
  else
    d90_soap_client="d90-soap-prod-client-jks"
    services04_crt="dvla-SERVICES04-CA-crt"
    services03_crt="dvla-SERVICES03-CA-crt"
    d90_soap_crt="D90-SOAP-PROD-crt"
    d90_soap_private_key="D90-SOAP-PROD-private-key"
    d90_soap="d90_soap_prod"
    d90_keystore="d90_soap_prod_client"
  fi

  log 'INFO' "services04_crt is $${services04_crt}"
  log 'INFO' "services03_crt is $${services03_crt}"
  log 'INFO' 'Creating temporary directory to store keystores'
  mkdir -p "$${certificate_directory}/keystores"

  log 'INFO' "Retrieving ${ACCOUNT_ENVIRONMENT} d90 passwords"
  d90_key_store_password=$($${aws} ssm get-parameter --name "/${ACCOUNT_ENVIRONMENT}/tars/d90/certificates/keystore/passwords/$${d90_soap_client}" --with-decryption --query 'Parameter.Value' --output text)
  d90_trust_store_password=$($${aws} ssm get-parameter --name "/${ACCOUNT_ENVIRONMENT}/tars/d90/certificates/shared/keystore/passwords/d90-trust-store-jks" --with-decryption --query 'Parameter.Value' --output text)

  log 'INFO' "Retrieving ${ACCOUNT_ENVIRONMENT} $${d90_soap} certificate"
  $${aws} ssm get-parameter --name /${ACCOUNT_ENVIRONMENT}/tars/d90/certificates/$${d90_soap_crt} --with-decryption --query 'Parameter.Value' --output text > $${certificate_directory}/$${d90_soap_crt}.crt
  log 'INFO' "Retrieving ${ACCOUNT_ENVIRONMENT} $${d90_soap} certificate private key"
  $${aws} ssm get-parameter --name /${ACCOUNT_ENVIRONMENT}/tars/d90/certificates/$${d90_soap_private_key} --with-decryption --query 'Parameter.Value' --output text > $${certificate_directory}/$${d90_soap_private_key}.key

  log 'INFO' "Retrieving ${ACCOUNT_ENVIRONMENT} $${d90_soap} root and intermediate certificates"
  $${aws} ssm get-parameter --name /${ACCOUNT_ENVIRONMENT}/tars/d90/certificates/$${services03_crt} --with-decryption --query 'Parameter.Value' --output text > $${certificate_directory}/$${services03_crt}.crt
  $${aws} ssm get-parameter --name /${ACCOUNT_ENVIRONMENT}/tars/d90/certificates/$${services04_crt} --with-decryption --query 'Parameter.Value' --output text > $${certificate_directory}/$${services04_crt}.crt
  
  log 'INFO' "Creating ${ACCOUNT_ENVIRONMENT} $${d90_soap} certificate chain"
  cat $${certificate_directory}/$${d90_soap_crt}.crt $${certificate_directory}/$${services04_crt}.crt $${certificate_directory}/$${services03_crt}.crt > $${certificate_directory}/d90-chain.pem
  
  log 'INFO' "Creating ${ACCOUNT_ENVIRONMENT} $${d90_soap} pk12"
  openssl pkcs12 -export -inkey $${certificate_directory}/$${d90_soap_private_key}.key -in $${certificate_directory}/$${d90_soap_crt}.crt -certfile $${certificate_directory}/d90-chain.pem -name $${d90_soap} -out $${certificate_directory}/$${d90_soap}.p12 -passout pass:$d90_key_store_password

  log 'INFO' "Creating ${ACCOUNT_ENVIRONMENT} $${d90_keystore}.jks keystore and importing $${certificate_directory}/$${d90_soap}.p12"
  $${java_path}/keytool -importkeystore -srckeystore $${certificate_directory}/$${d90_soap}.p12 -srcstoretype pkcs12 -destkeystore $${certificate_directory}/keystores/$${d90_keystore}.jks -deststorepass $d90_key_store_password -srcstorepass $d90_key_store_password

  log 'INFO' "Retrieving ${ACCOUNT_ENVIRONMENT} d90 trusted certificates"
  $${aws} ssm get-parameter --name /${ACCOUNT_ENVIRONMENT}/tars/d90/certificates/shared/INTERMEDIATE-DigiCert-SHA2-Extended-Validation-Server-CA-crt --with-decryption --query 'Parameter.Value' --output text > $${certificate_directory}/INTERMEDIATE-DigiCert-SHA2-Extended-Validation-Server-CA.crt
  $${aws} ssm get-parameter --name /${ACCOUNT_ENVIRONMENT}/tars/d90/certificates/shared/ROOT-DigiCert-High-Assurance-EV-Root-CA-crt --with-decryption --query 'Parameter.Value' --output text > $${certificate_directory}/ROOT-DigiCert-High-Assurance-EV-Root-CA.crt
  $${aws} ssm get-parameter --name /${ACCOUNT_ENVIRONMENT}/tars/d90/certificates/shared/dvla-UASERVICES03-CA-crt --with-decryption --query 'Parameter.Value' --output text > $${certificate_directory}/dvla-UASERVICES03-CA-crt-shared.crt
  $${aws} ssm get-parameter --name /${ACCOUNT_ENVIRONMENT}/tars/d90/certificates/shared/dvla-UASERVICES04-CA-crt --with-decryption --query 'Parameter.Value' --output text > $${certificate_directory}/dvla-UASERVICES04-CA-crt-shared.crt
  $${aws} ssm get-parameter --name /${ACCOUNT_ENVIRONMENT}/tars/d90/certificates/shared/quovadis-ev-ssl-ica-g1-crt --with-decryption --query 'Parameter.Value' --output text > $${certificate_directory}/QuoVadisEVSSLICAG1.crt
  $${aws} ssm get-parameter --name /${ACCOUNT_ENVIRONMENT}/tars/d90/certificates/shared/QuoVadisRoot-crt --with-decryption --query 'Parameter.Value' --output text > $${certificate_directory}/QuoVadisRoot.pem.crt
  $${aws} ssm get-parameter --name /${ACCOUNT_ENVIRONMENT}/tars/d90/certificates/shared/quovadis-root-ca-2-g3-crt --with-decryption --query 'Parameter.Value' --output text > $${certificate_directory}/quovadis-root-ca-2-g3.crt
  $${aws} ssm get-parameter --name /${ACCOUNT_ENVIRONMENT}/tars/d90/certificates/shared/quovadis-europe-ev-ssl-ca-g1-crt --with-decryption --query 'Parameter.Value' --output text > $${certificate_directory}/quovadis-europe-ev-ssl-ca-g1.crt

  log 'INFO' "Creating ${ACCOUNT_ENVIRONMENT} d90 truststore and importing trusted certificates"
  $${java_path}/keytool -importcert -trustcacerts -keystore $${certificate_directory}/keystores/d90_trust_store.jks -deststorepass $d90_trust_store_password -noprompt -file $${certificate_directory}/INTERMEDIATE-DigiCert-SHA2-Extended-Validation-Server-CA.crt -alias "digitcertroot20281022"
  $${java_path}/keytool -importcert -trustcacerts -keystore $${certificate_directory}/keystores/d90_trust_store.jks -deststorepass $d90_trust_store_password -noprompt -file $${certificate_directory}/ROOT-DigiCert-High-Assurance-EV-Root-CA.crt -alias "digitcertroot20311110"
  $${java_path}/keytool -importcert -trustcacerts -keystore $${certificate_directory}/keystores/d90_trust_store.jks -deststorepass $d90_trust_store_password -noprompt -file $${certificate_directory}/dvla-UASERVICES03-CA-crt-shared.crt -alias "dvla-uaservices03-ca"
  $${java_path}/keytool -importcert -trustcacerts -keystore $${certificate_directory}/keystores/d90_trust_store.jks -deststorepass $d90_trust_store_password -noprompt -file $${certificate_directory}/dvla-UASERVICES04-CA-crt-shared.crt -alias "dvla-uaservices04-ca"
  $${java_path}/keytool -importcert -trustcacerts -keystore $${certificate_directory}/keystores/d90_trust_store.jks -deststorepass $d90_trust_store_password -noprompt -file $${certificate_directory}/QuoVadisEVSSLICAG1.crt -alias "quovadis-ev-ssl-ica-g1"
  $${java_path}/keytool -importcert -trustcacerts -keystore $${certificate_directory}/keystores/d90_trust_store.jks -deststorepass $d90_trust_store_password -noprompt -file $${certificate_directory}/QuoVadisRoot.pem.crt -alias "quovadis-root-ca-2"
  $${java_path}/keytool -importcert -trustcacerts -keystore $${certificate_directory}/keystores/d90_trust_store.jks -deststorepass $d90_trust_store_password -noprompt -file $${certificate_directory}/quovadis-root-ca-2-g3.crt -alias "quovadis-root-ca2-g3"
  $${java_path}/keytool -importcert -trustcacerts -keystore $${certificate_directory}/keystores/d90_trust_store.jks -deststorepass $d90_trust_store_password -noprompt -file $${certificate_directory}/quovadis-europe-ev-ssl-ca-g1.crt -alias "quovadis-ssl-ica-g3-new"

  if [ -f "/opt/d90wrapper/conf/$${d90_keystore}.jks" ]; then
    log 'INFO' "Backing up /opt/d90wrapper/conf/$${d90_keystore}.jks"
    mv /opt/d90wrapper/conf/$${d90_keystore}.jks /opt/d90wrapper/conf/$${d90_keystore}-original.jks
  fi

  if [ -f "/opt/d90wrapper/conf/d90_trust_store.jks" ]; then
    log 'INFO' "Backing up /opt/d90wrapper/conf/d90_trust_store.jks"
    mv /opt/d90wrapper/conf/d90_trust_store.jks /opt/d90wrapper/conf/d90_trust_store-original.jks
  fi

  log 'INFO' "Copying $${d90_keystore}.jks keystore to /opt/d90wrapper/conf/$${d90_keystore}.jks"
  cp $${certificate_directory}/keystores/$${d90_keystore}.jks /opt/d90wrapper/conf
  log 'INFO' "Copying d90_trust_store.jks to /opt/d90wrapper/conf"
  cp $${certificate_directory}/keystores/d90_trust_store.jks /opt/d90wrapper/conf/d90_trust_store.jks

  chown d90wrapper:d90wrapper /opt/d90wrapper/conf/$${d90_keystore}.jks
  chown d90wrapper:d90wrapper /opt/d90wrapper/conf/d90_trust_store.jks
  chmod 750 /opt/d90wrapper/conf/$${d90_keystore}.jks
  chmod 750 /opt/d90wrapper/conf/d90_trust_store.jks

  log 'INFO' 'Deleting temporary directory to store keystores'
  rm -fR $${certificate_directory}
fi

/etc/init.d/d90wrapper restart

echo """
[
  {
    \"timestamp\": $${timestamp},
    \"message\": $${log_data}
  }
]""" > /var/log/cwl-cloud-init.txt

aws logs create-log-stream \
  --region $${region} \
  --log-group-name ${LOG_GROUP} \
  --log-stream-name $${instance_id}

aws logs put-log-events \
  --region $${region} \
  --log-group-name ${LOG_GROUP} \
  --log-stream-name $${instance_id} \
  --log-events file:///var/log/cwl-cloud-init.txt


log 'INFO' 'Completing lifecycle action'

if [ $${BOOTSTRAP_SUCCESS} -eq 1 ]; then
  $${aws} autoscaling complete-lifecycle-action \
      --lifecycle-action-result CONTINUE \
      --instance-id "$${instance_id}" \
      --lifecycle-hook-name "$${lifecycle_hook_name}" \
      --auto-scaling-group-name "$${asg_name}" \
      || error 'Failed to complete lifecycle hook';
else
  $${aws} autoscaling complete-lifecycle-action \
    --lifecycle-action-result ABANDON \
    --instance-id "$${instance_id}" \
    --lifecycle-hook-name "$${lifecycle_hook_name}" \
    --auto-scaling-group-name "$${asg_name}" \
    || error 'Failed to complete lifecycle hook';
fi

# Now puppet has finished and we don't need to lookup KMS keys, we can override DNS
# Override DNS to use DVSA Azure DNS. TF knows what the IP's are so lets do it here, rather than puppet
servers=$(echo ${DVSA_DNS_SERVERS} | sed 's/,/ /g' | sed 's,/32,,g')
# If we can't ping the DVSA DNS server, don't apply and leave the R53 DNS settings in place
if ping -q -W 1 -c 1 $(echo "$servers" | cut -d" " -f1) > /dev/null 2>&1
then
  log 'INFO' 'Setting DVSA DNS'
  echo "search ${SEARCH_SUFFIX}" > /etc/resolv.conf
  for server in $servers
  do
    echo "nameserver $${server}" >> /etc/resolv.conf
  done
else
  log 'INFO' 'Using R53 DNS'
fi

log 'INFO' 'Checking Arvato Key'
# copying the current sshhostkey to try
mkdir  -p ~/.putty
cp /opt/SFTPPlus-client/.putty/sshhostkeys ~/.putty/sshhostkeys
# get values from config files
export user=$(awk '/user/{print $3}' /opt/SFTPPlus-client/conf/Payord_Put.conf | tr -d \')
export password=$(awk '/password/{print $3}' /opt/SFTPPlus-client/conf/Payord_Put.conf | tr -d \')
export host=$(awk '/server/{print $3}' /opt/SFTPPlus-client/conf/Payord_Put.conf | tr -d \')

if [ $${host} == "tars-mock-sftp" ]; then
  log 'INFO' 'Using SFTP Mock'
  exit
else
  # make batch connection that will end if any user input required, i.e. password if sshkey present, or sshkey if changed
  result=$(/opt/SFTPPlus-client/bin/psftp $${user}@$${host} -batch 2>&1)
  if [[ $result == *"Connection abandoned"* ]]; then
     log 'ERROR' '********ARVATO KEY HAS CHANGED*********'
     log 'ERROR' 'adding new key'
     rm -rf ~/.putty/sshhostkeys
     echo y bye | /opt/SFTPPlus-client/bin/psftp $${user}@$${host} -pw $${password}
     cat ~/.putty/sshhostkeys > /opt/SFTPPlus-client/.putty/sshhostkeys
     service sftpplus stop
     sleep 2
     service sftpplus free
     sleep 2
     service sftpplus start
  elif [[ $result == *"Name or service not known"* ]]; then
     log 'ERROR' '********ARVATO SERVICE CONNECTION ERROR*********'
     log 'ERROR' 'Arvato Key not changed'
  else
     log 'INFO' 'Arvato Key not changed'
  fi
fi
