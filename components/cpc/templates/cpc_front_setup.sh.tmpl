#!/bin/bash +x

function log () {
  case $1 in
    "INFO")
      LOG_COLOR="\033[96m";;
    "ERROR")
      LOG_COLOR="\033[31m";;
    "WARN")
      LOG_COLOR="\033[93m" ;;
    "SUCCESS")
      LOG_COLOR="\033[32m" ;;
    *)
      LOG_COLOR="\033[1m" ;;
  esac

  echo -e "$${LOG_COLOR} [$(date)] $${1}: $2\033[0m" | tee -a "/var/log/bootstrap.log"
}

function error () {
  log "ERROR" "$1"
  exit
}

# Python is the best bet to safely escape the log data
# for json consumption. json is a std python lib so 
# minimal dependency requirements
function json_escape () {
    printf '%s' "$1" | python -c 'import json,sys; print(json.dumps(sys.stdin.read()))'
}

export aws="$(which aws || echo '/usr/bin/aws')";
export curl="$(which curl || echo '/usr/bin/curl')";

# Instance ID begets all things...
log 'INFO' 'Retrieving Instance ID from Metadata';
instance_id="$($${curl} -s http://169.254.169.254/latest/meta-data/instance-id)";
if [ $${?} -ne 0 ]; then
  error "Failed to retrieve Instance ID";
fi
log 'INFO' "Instance ID: $${instance_id}";

# Get Current AWS Region in order to do anything useful...
log 'INFO' 'Retrieving Instance Identity Document from Metadata';
instance_identity_document="$($${curl} -s http://169.254.169.254/latest/dynamic/instance-identity/document)";
if [ $${?} -ne 0 ]; then
  error "$${curl} -s http://169.254.169.254/latest/dynamic/instance-identity/document";
else
  log 'INFO' 'Instance Identity Document Retrieved';

  region="$(echo "$${instance_identity_document}" | jq -r .region)";

  if [ $${?} -ne 0 ]; then
    error 'jq: Instance Identity Document could not be parsed for current Region';
  else
    log 'INFO' "Region retrieved: $${region}";
  fi;

  # Make it available to the AWS cli; who needs to specify the region manually on every single call(?)
  export AWS_DEFAULT_REGION="$${region}";
fi;

# Get the Autoscaling Group Name - it's a bit dirty but it works.
asg_name="$($${aws} autoscaling describe-auto-scaling-instances \
  --instance "$${instance_id}" \
  --output json \
  | jq -r .AutoScalingInstances[0].AutoScalingGroupName)";

if [ $${?} -ne 0 ]; then
  error 'Failed to retrieve the autoscaling group name for this instance';
else
  log 'INFO' "ASG name retrieved: $${asg_name}";
fi;

# Get the Launching LifeCycle Hook Name for this ASG (Making the assumption there's only one hook!)
lifecycle_hook_name="$($${aws} autoscaling describe-lifecycle-hooks \
  --auto-scaling-group-name "$${asg_name}" \
  --output json \
  | jq -r '.LifecycleHooks[] | select(.LifecycleTransition=="autoscaling:EC2_INSTANCE_LAUNCHING") | .LifecycleHookName')";

if [ $${?} -ne 0 ]; then
  error "Failed to retrieve lifecycle hook name for the autoscaling:EC2_INSTANCE_LAUNCHING transition for the autoscaling group named: $${asg_name}";
else
  log 'INFO' "Lifecycle hook name retrieved: $${lifecycle_hook_name}"
fi;

# Prerequisite information gathered - begin bootstrapping

BOOTSTRAP_SUCCESS=1
curl_cmd="curl --connect-timeout 3 -s -f http://CPC-BACKEND:8080/training-centre/TrainingCentreWebService/TrainingCentre?wsdl 2>&1 > /dev/null"
retries=40
retry_delay=10
backend=1
log 'INFO' 'Waiting for backend to respond'

for ((trys=1;trys<=$${retries};trys++));
do
  eval $${curl_cmd}
  if [ $? -eq 0 ]
  then
    log 'INFO' 'Backend responding'
    backend=0
    break
  else
    log 'INFO' 'Backend failed to respond. Retrying..'
    sleep $${retry_delay}
  fi
done

if [ $${backend} -eq 0  ]
then
  log 'INFO' 'Running puppet to configure environment'

  sed -E -i "s/'[a-z0-9]{8}\-[a-z0-9]{4}\-[a-z0-9]{4}\-[a-f0-9]{4}\-[a-z0-9]{12}'/'${KMS_KEY}'/g" /etc/eyaml/config.yaml

  # Shift this to cloud-init config yaml
  facts_path="/opt/puppetlabs/facter/facts.d"
  echo -n 'environment: ${ENVIRONMENT}'    > "$${facts_path}/environment.yaml"
  echo -n 'nodetype: ${NODETYPE}'          > "$${facts_path}/nodetype.yaml"
  echo -n 'aws_account: ${AWS_ACCOUNT_ID}' > "$${facts_path}/aws_account.yaml"
  echo -n 'domain: ${PRIVATE_DOMAIN}' > "$${facts_path}/domain.yaml"

  cd /opt/packer-puppet-masterless

  /opt/puppetlabs/bin/puppet apply \
    --verbose \
    --detailed-exitcodes \
    --modulepath='/opt/packer-puppet-masterless/module-0:/opt/packer-puppet-masterless/module-1' \
    --hiera_config='/opt/packer-puppet-masterless/hiera.yaml' \
    /opt/packer-puppet-masterless/manifests/site.pp

  case $${?} in
    6|4|1)
      log "ERROR" "Puppet run failed with exit code $${?}"
      BOOTSTRAP_SUCCESS=0 ;;
    *)
      log "INFO" "Puppet run completed" ;;
  esac

  log 'INFO' 'Puppet configuration finished'
else
  log 'ERROR' 'Could not contact backend'
  BOOTSTRAP_SUCCESS=0
fi

log 'INFO' "Account_environment is ${ACCOUNT_ENVIRONMENT}"
# these variables are used for retrieval of certificates for elise from parameter store
if [ "${ACCOUNT_ENVIRONMENT}" == "nonprod" ]; then
  cpc_certificate_name="cpc-nonprod-dvsa-gov-uk"
  pk12_name="testelise"
  jssecacerts_keystore="testelise"
else
  cpc_certificate_name="cpc-dvsa-gov-uk"
  pk12_name="prodelise"
  jssecacerts_keystore="productionelise"
fi

# elise keystore configuration#
log 'INFO' 'Beginning ${ACCOUNT_ENVIRONMENT} elise certificate keystore configuration'
log 'INFO' 'Creating temporary directory to store keystores'
certificate_directory="/tmp/cert"
cpc_prop_home="/opt/wildfly/cpc_prop_home"
java_path="/usr/lib/jvm/java-1.8.0-amazon-corretto.x86_64/bin"
mkdir -p "$${certificate_directory}/keystores"

log 'INFO' 'Retrieving ${ACCOUNT_ENVIRONMENT} elise passwords'
cpc_keystore_password=$(aws ssm get-parameter --name "/${ACCOUNT_ENVIRONMENT}/cpc/all/certificates/elise/keystore/cpc-password" --with-decryption --query 'Parameter.Value' --output text)
elise_keystore_password=$(aws ssm get-parameter --name "/${ACCOUNT_ENVIRONMENT}/cpc/all/certificates/elise/keystore/elise-jssecacerts" --with-decryption --query 'Parameter.Value' --output text)
elise_pk12_password=$(aws ssm get-parameter --name "/${ACCOUNT_ENVIRONMENT}/cpc/all/certificates/elise/elise-pk12-password" --with-decryption --query 'Parameter.Value' --output text)

log 'INFO' "Retrieving ${ACCOUNT_ENVIRONMENT} cpc certificate"
aws ssm get-parameter --with-decryption --query 'Parameter.Value' --output text --name "/${ACCOUNT_ENVIRONMENT}/cpc/all/certificates/elise/cpc-crt"  > "$${certificate_directory}/$${cpc_certificate_name}.crt"
aws ssm get-parameter --with-decryption --query 'Parameter.Value' --output text --name "/${ACCOUNT_ENVIRONMENT}/cpc/all/certificates/elise/cpc-private-key"  > "$${certificate_directory}/$${cpc_certificate_name}-private.key"

log 'INFO' "Retrieving ${ACCOUNT_ENVIRONMENT} Trusted Root and Intermediate certificates"
aws ssm get-parameter --with-decryption --query 'Parameter.Value' --output text --name "/${ACCOUNT_ENVIRONMENT}/cpc/all/certificates/elise/trusted/TrustedRoot-crt"  > "$${certificate_directory}/TrustedRoot-crt.pem"
aws ssm get-parameter --with-decryption --query 'Parameter.Value' --output text --name "/${ACCOUNT_ENVIRONMENT}/cpc/all/certificates/elise/trusted/IntermediateCA-crt" > "$${certificate_directory}/IntermediateCA-crt.pem"

log 'INFO' "Creating certificate chain"
cat "/$${certificate_directory}/$${cpc_certificate_name}.crt" "$${certificate_directory}/TrustedRoot-crt.pem" "$${certificate_directory}/IntermediateCA-crt.pem" > "$${certificate_directory}/ca-chain-bundle.cert.pem"

log 'INFO' "Converting certificate to pk12"
openssl pkcs12 -export -inkey "$${certificate_directory}/$${cpc_certificate_name}-private.key" -in "$${certificate_directory}/$${cpc_certificate_name}.crt" -certfile "$${certificate_directory}/ca-chain-bundle.cert.pem" -name "$${pk12_name}" -out "$${certificate_directory}/$${pk12_name}.p12" -passout pass:$elise_pk12_password

log 'INFO' "Adding $${pk12_name} certificate to ${ACCOUNT_ENVIRONMENT} cpc wildfly keystore"
"$${java_path}/keytool" -importkeystore -srckeystore "$${certificate_directory}/$${pk12_name}.p12" -srcstoretype pkcs12 -destkeystore "$${certificate_directory}/keystores/cpc-wildfly-keystore.jks" -deststorepass $cpc_keystore_password -srcstorepass $elise_pk12_password

log 'INFO' "Adding $${pk12_name} certificate to ${ACCOUNT_ENVIRONMENT} $${jssecacerts_keystore}-jssecacerts keystore"
"$${java_path}/keytool" -importkeystore -srckeystore "$${certificate_directory}/$${pk12_name}.p12" -srcstoretype pkcs12 -destkeystore "$${certificate_directory}/keystores/$${jssecacerts_keystore}-jssecacerts" -deststorepass $elise_keystore_password -srcstorepass $elise_pk12_password

log 'INFO' "Retrieving trusted certificates for ${ACCOUNT_ENVIRONMENT} cpc wildfly truststore"
aws ssm get-parameter --with-decryption --query 'Parameter.Value' --output text --name "/${ACCOUNT_ENVIRONMENT}/cpc/all/certificates/elise/trusted/censysactivemqca" > "$${certificate_directory}/censysactivemqca.pem"
aws ssm get-parameter --with-decryption --query 'Parameter.Value' --output text --name "/${ACCOUNT_ENVIRONMENT}/cpc/all/certificates/elise/trusted/digicertroot" > "$${certificate_directory}/digicertroot.pem"
aws ssm get-parameter --with-decryption --query 'Parameter.Value' --output text --name "/${ACCOUNT_ENVIRONMENT}/cpc/all/certificates/elise/trusted/digicertintermediate" > "$${certificate_directory}/digicertintermediate.pem"


log 'INFO' "Adding trusted certificates to ${ACCOUNT_ENVIRONMENT} cpc wildfly truststore"
log 'INFO' "Adding censysactivemqca trusted certificate to ${ACCOUNT_ENVIRONMENT} cpc wildfly truststore"
"$${java_path}/keytool" -importcert -trustcacerts -keystore "$${certificate_directory}/keystores/cpc-wildfly-truststore.jks" -deststorepass $cpc_keystore_password -noprompt -file "$${certificate_directory}/censysactivemqca.pem" -alias censysactivemqca

log 'INFO' "Adding digicertroot trusted certificate to ${ACCOUNT_ENVIRONMENT} cpc wildfly truststore"
"$${java_path}/keytool" -importcert -trustcacerts -keystore "$${certificate_directory}/keystores/cpc-wildfly-truststore.jks" -deststorepass $cpc_keystore_password -noprompt -file "$${certificate_directory}/digicertroot.pem" -alias digicertroot

log 'INFO' "Adding digicertintermediate trusted certificate to ${ACCOUNT_ENVIRONMENT} cpc wildfly truststore"
"$${java_path}/keytool" -importcert -trustcacerts -keystore "$${certificate_directory}/keystores/cpc-wildfly-truststore.jks" -deststorepass $cpc_keystore_password -noprompt -file "$${certificate_directory}/digicertintermediate.pem" -alias digicertintermediate

if [ "${ACCOUNT_ENVIRONMENT}" == "nonprod" ]; then
  log 'INFO' "Retrieving additional trusted certificates for ${ACCOUNT_ENVIRONMENT} cpc wildfly truststore"
  aws ssm get-parameter --with-decryption --query 'Parameter.Value' --output text --name "/${ACCOUNT_ENVIRONMENT}/cpc/all/certificates/elise/trusted/ua-services03-root" > "$${certificate_directory}/ua_services03_root.pem"
  aws ssm get-parameter --with-decryption --query 'Parameter.Value' --output text --name "/${ACCOUNT_ENVIRONMENT}/cpc/all/certificates/elise/trusted/ua-services04-intermediate" > "$${certificate_directory}/ua_services04_intermediate.pem"

  log 'INFO' "Adding additional trusted certificates to ${ACCOUNT_ENVIRONMENT} cpc wildfly truststore"
  log 'INFO' "Adding ua_services03_root trusted certificate to ${ACCOUNT_ENVIRONMENT} cpc wildfly truststore"
  "$${java_path}/keytool" -importcert -trustcacerts -keystore "$${certificate_directory}/keystores/cpc-wildfly-truststore.jks" -deststorepass $cpc_keystore_password -noprompt -file "$${certificate_directory}/ua_services03_root.pem" -alias ua_services03_root
  log 'INFO' "Adding ua_services04_intermediate trusted certificate to ${ACCOUNT_ENVIRONMENT} cpc wildfly truststore"
  "$${java_path}/keytool" -importcert -trustcacerts -keystore "$${certificate_directory}/keystores/cpc-wildfly-truststore.jks" -deststorepass $cpc_keystore_password -noprompt -file "$${certificate_directory}/ua_services04_intermediate.pem" -alias ua_services04_intermediate
fi
  
  if [ "${ACCOUNT_ENVIRONMENT}" == "live" ]; then
    # if any additional trusted certs are needed for live, they can be added here
    # the certficates listed below may not be needed
    log 'INFO' "Retrieving additional trusted certificates for ${ACCOUNT_ENVIRONMENT} $${jssecacerts_keystore}-jssecacert"
    aws ssm get-parameter --with-decryption --query 'Parameter.Value' --output text --name "/${ACCOUNT_ENVIRONMENT}/cpc/all/certificates/elise/trusted/quovadisintermediate" > "$${certificate_directory}/quovadisintermediate.pem"
    aws ssm get-parameter --with-decryption --query 'Parameter.Value' --output text --name "/${ACCOUNT_ENVIRONMENT}/cpc/all/certificates/elise/trusted/quovadisroot" > "$${certificate_directory}/quovadisroot.pem"
    aws ssm get-parameter --with-decryption --query 'Parameter.Value' --output text --name "/${ACCOUNT_ENVIRONMENT}/cpc/all/certificates/elise/trusted/root" > "$${certificate_directory}/root.pem"

    log 'INFO' "Adding additional trusted certificates to ${ACCOUNT_ENVIRONMENT} $${jssecacerts_keystore}-jssecacert"
    log 'INFO' "Adding quovadisintermediate trusted certificate to ${ACCOUNT_ENVIRONMENT} $${jssecacerts_keystore}-jssecacert"
    "$${java_path}/keytool" -importcert -trustcacerts -keystore "$${certificate_directory}/keystores/$${jssecacerts_keystore}-jssecacerts" -deststorepass $elise_keystore_password -noprompt -file "$${certificate_directory}/quovadisintermediate.pem" -alias quovadisintermediate
    log 'INFO' "Adding quovadisroot trusted certificate to ${ACCOUNT_ENVIRONMENT} $${jssecacerts_keystore}-jssecacert"
    "$${java_path}/keytool" -importcert -trustcacerts -keystore "$${certificate_directory}/keystores/$${jssecacerts_keystore}-jssecacerts" -deststorepass $elise_keystore_password -noprompt -file "$${certificate_directory}/quovadisroot.pem" -alias quovadisroot
    log 'INFO' "Adding root trusted certificate to ${ACCOUNT_ENVIRONMENT} $${jssecacerts_keystore}-jssecacert"
    "$${java_path}/keytool" -importcert -trustcacerts -keystore "$${certificate_directory}/keystores/$${jssecacerts_keystore}-jssecacerts" -deststorepass $elise_keystore_password -noprompt -file "$${certificate_directory}/root.pem" -alias root
  fi
  
# only copy keystores created from parameter store for nonprod, the if block can be removed when ready to copy for live account
if [ "${ACCOUNT_ENVIRONMENT}" == "nonprod" ]; then
  # keystores are currently in app repo so will get copied to cipher folders, take a back up if the keystores exist in cipher folders
  # when live is added, copying of keystore is to be moved after if [ "${ACCOUNT_ENVIRONMENT}" == "nonprod" ]; then statement block
  log 'INFO' "Preparing to copy keystores"
  log 'INFO' "Checking if keystores already existing and backing up if they do"
  if [ -f "$${cpc_prop_home}/wildfly-cipher/cpc-wildfly-keystore.jks" ]; then
    log 'INFO' "Backing up $${cpc_prop_home}/wildfly-cipher/cpc-wildfly-keystore.jks"
    mv "$${cpc_prop_home}/wildfly-cipher/cpc-wildfly-keystore.jks" "$${cpc_prop_home}/wildfly-cipher/cpc-wildfly-keystore-original.jks"
  fi
  if [ -f "$${cpc_prop_home}/wildfly-cipher/cpc-wildfly-truststore.jks" ]; then
    log 'INFO' "Backing up $${cpc_prop_home}/wildfly-cipher/cpc-wildfly-truststore.jks"
    mv "$${cpc_prop_home}/wildfly-cipher/cpc-wildfly-truststore.jks" "$${cpc_prop_home}/wildfly-cipher/cpc-wildfly-truststore-original.jks"
  fi
  if [ -f "$${cpc_prop_home}/cipher/$${jssecacerts_keystore}-jssecacerts" ]; then # test this change in opsdev
    log 'INFO' "Backing up $${cpc_prop_home}/cipher/$${jssecacerts_keystore}-jssecacerts" # test this change in opsdev
    mv "$${cpc_prop_home}/cipher/$${jssecacerts_keystore}-jssecacerts" "$${cpc_prop_home}/cipher/$${jssecacerts_keystore}-jssecacerts-original" # test this change in opsdev
  fi

  log 'INFO' "Copying keystores to /opt/wildfly/cpc_prop_home/wildfly-cipher"
  cp "$${certificate_directory}/keystores/cpc-wildfly-keystore.jks" "$${cpc_prop_home}/wildfly-cipher/"
  cp "$${certificate_directory}/keystores/cpc-wildfly-truststore.jks" "$${cpc_prop_home}/wildfly-cipher/"
  cp "$${certificate_directory}/keystores/$${jssecacerts_keystore}-jssecacerts" "$${cpc_prop_home}/cipher/$${jssecacerts_keystore}-jssecacerts" # test this change in opsdev
  chown wildfly:wildfly "$${cpc_prop_home}/wildfly-cipher/cpc-wildfly-keystore.jks" # test this change in opsdev
  chown wildfly:wildfly "$${cpc_prop_home}/wildfly-cipher/cpc-wildfly-truststore.jks" # test this change in opsdev
  chown wildfly:wildfly "$${cpc_prop_home}/cipher/$${jssecacerts_keystore}-jssecacerts" # test this change in opsdev

  log 'INFO' 'Cleaning up temporary directory used to store keystores'
  rm -Rf "$${certificate_directory}"

  log 'INFO' 'Restarting wildfly'
  systemctl restart wildfly.service

else
  log 'INFO' "account is live so retrieved certificates from parameter store and placed into $${certificate_directory} only"
fi


if [ $${BOOTSTRAP_SUCCESS} -eq 1 ]; then
  log 'SUCCESS' 'Bootstrap complete for nodetype: ${NODETYPE}'
else
  log 'ERROR' 'Bootstrap abandon for nodetype: ${NODETYPE}'
fi

sed -i -e "s|production|${ENVIRONMENT}|g" /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.toml
/etc/init.d/cloudwatch restart

# Sure would be lovely if date could give unix time 
# in milliseconds
timestamp=$(($(date +'%s * 1000 + %-N / 1000000')))
log_data="$(json_escape "$(cat /var/log/cloud-init-output.log)")"

echo """
[
  {
    \"timestamp\": $${timestamp},
    \"message\": $${log_data}
  }
]""" > /var/log/cwl-cloud-init.txt

aws logs create-log-stream \
  --region $${region} \
  --log-group-name ${LOG_GROUP} \
  --log-stream-name $${instance_id}

aws logs put-log-events \
  --region $${region} \
  --log-group-name ${LOG_GROUP} \
  --log-stream-name $${instance_id} \
  --log-events file:///var/log/cwl-cloud-init.txt

log 'INFO' 'Completing lifecycle action'

if [ $${BOOTSTRAP_SUCCESS} -eq 1 ]; then
  $${aws} autoscaling complete-lifecycle-action \
      --lifecycle-action-result CONTINUE \
      --instance-id "$${instance_id}" \
      --lifecycle-hook-name "$${lifecycle_hook_name}" \
      --auto-scaling-group-name "$${asg_name}" \
      || error 'Failed to complete lifecycle hook';
else
  $${aws} autoscaling complete-lifecycle-action \
    --lifecycle-action-result ABANDON \
    --instance-id "$${instance_id}" \
    --lifecycle-hook-name "$${lifecycle_hook_name}" \
    --auto-scaling-group-name "$${asg_name}" \
    || error 'Failed to complete lifecycle hook';
fi

